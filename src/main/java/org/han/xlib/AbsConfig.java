package org.han.xlib;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * org.han.xlib Custom Configuration Handler </br>
 * This was easier then learning yalm...took me 30 minutes to code </br>
 * </br>
 * 
 * This is meant to form the basis for a Configuration class.
 * 
 * @author hanro50
 * @version 1.0
 */
public abstract class AbsConfig {
	private final Map<String, String> InternalSave = new HashMap<String, String>();
	private final File SaveFile;
	protected boolean NEWCONFIG;

	private String Settingsfilter(String in) {
		return in.replaceAll("\n", "").replaceAll(":", "").replaceAll("\\\\", "");
	}
	private String returnfilter(String in) {
		return in.replaceAll("\n", "");
	}
	
	
	/**
	 * Will generate the Configuration file if it doesn't already exist. </br>
	 * As well as load the Configurations into memory. </br>
	 * 
	 * @implNote <b> Warning:</b>Because this will run before the Registration
	 *           commands have a chance to be ran. It might load stuff that it
	 *           doesn't know isn't Configuration options. If you remove a
	 *           Configuration option. It will still be loaded into memory even if
	 *           it isn't used. Please manually update Configuration options
	 *           accordingly
	 * @param Defaultfile The File the Configuration should be saved to
	 */
	protected AbsConfig(File Defaultfile) {
		SaveFile = Defaultfile;
		NEWCONFIG = !SaveFile.exists();
		if (!NEWCONFIG) {
			try {
				String[] File = FileObj.read(Defaultfile);
				for (String string : File) {
					if (string != null && string.length() > 2 && !string.subSequence(0, 2).equals("\\\\")
							&& string.split(":", 2).length == 2) {
						InternalSave.put(string.split(":", 2)[0], string.split(":", 2)[1]);
					}
				}
			} catch (IOException e) {
			}
		} else {
			try {
				FileObj.writeNF(new String[] { "\\\\Generated by AbsConfig within han.org.xlib", "" }, Defaultfile,
						"Confing file");
			} catch (IOException e) {
				Debug.err("Failed to write config option...things are about to go...wrong");
			}
		}
	}

	/**
	 * Register a Configuration Option
	 * 
	 * @param HelpText     The Help text placed on the top of the command
	 * @param Setting      The Setting Key
	 * @param Defaultvalue It's Default value
	 */
	protected void Register(String HelpText, String Setting, String Defaultvalue) {
		if (InternalSave.containsKey(Setting))
			return;
		try {
			String File = FileObj.read(SaveFile, "\n");
			HelpText = "\\\\" + HelpText.replaceAll("\n", "\n\\\\\\\\");
			Setting = Settingsfilter(Setting);  
			Defaultvalue = returnfilter(Defaultvalue);
			FileObj.writeNF(new String[] { File, HelpText, Setting + ":" + Defaultvalue }, SaveFile, "Config Options");
			InternalSave.put(Setting, Defaultvalue);
		} catch (IOException e) {
			// TODO Auto-generated catch block
			Debug.Trace(e);
		}
	}

	/**
	 * Returns a Configuration option based on a provided key from the internal
	 * configuration map
	 * 
	 * @param Setting The Key
	 * @return Will return a blank String if the key is invalid
	 */
	protected String get(String Setting) {
		return InternalSave.getOrDefault(Settingsfilter(Setting) , "");
	}

	/**
	 * Edits a value from within the application. Useful for when you want to edit the Configuration options automatically.
	 * @param Setting The Key
	 * @param newSetting The new Value for that Key
	 * @throws IllegalArgumentException If the Key is invalid
	 * @implNote Please call {@link #Save() this.Save()} to make changes to Configuration options permanent
	 * 
	 */
	protected void edit(String Setting, String newSetting) throws IllegalArgumentException {
		Setting = Settingsfilter(Setting);  
		if (!InternalSave.containsKey(Setting))
			throw new IllegalArgumentException("Setting key does not exist");
		InternalSave.remove(Setting);
		InternalSave.put(Setting, returnfilter(newSetting));
	}

	/**
	 * Saves {@link #edit(String,String) edits} to the Configuration file to disk. </br>
	 * This will make those changes permanent
	 * @throws FileNotFoundException If the Configuration File no longer exists
	 * @throws IOException If the program cannot read or write to the Configuration File. </br>
	 * If the Configuration File no longer exists and if the FileNotFoundException isn't caught, then this also gets called.
	 */
	
	protected void Save() throws FileNotFoundException, IOException {
		if (!SaveFile.exists())
			throw new FileNotFoundException("Could not find config option");
		String[] File = FileObj.read(SaveFile);
		for (int i = 0; i < File.length; i++) {
			if (File[i] != null && File[i].length() > 2 && !File[i].subSequence(0, 1).equals("\\")
					&& File[i].split(":", 2).length == 2) {
				// InternalSave.put(string.split(":",2)[0], string.split(":",2)[1]);
				File[i] = File[i].split(":", 2)[0] + ":" + InternalSave.get(File[i].split(":", 2)[0]);
			}
		}
		FileObj.writeNF(File, SaveFile, "Confing file");
		
	}
	/**
	 * Grabs a Configuration option and checks to see if it equals true
	 * 
	 * @param Setting The Key
	 * @return True if the setting contains the value "true" (Case ignored)
	 */
	protected boolean boolcheck(String setting) {
		return get(setting).trim().equalsIgnoreCase("true");
	}
	/**
	 * Grabs a Configuration option and checks what value it is equal to. 
	 * @param setting The Key
	 * @param DefaultVal The value to return if the setting isn't a valid number
	 * @return The value of the setting
	 */
	protected int Valuecheck(String setting, int DefaultVal) {
		try {
			return Integer.valueOf(get(setting).trim());
		} catch (NumberFormatException e) {
			Debug.err("Config option isn't a valid value. Please select a integer value for option: \""
					+ setting + "\" in this plugin's app config options");
			Debug.err("Returning default value of " +DefaultVal );
			edit(setting,""+(DefaultVal));
			try {
				Save();
			} catch (IOException e1) {
			}
			return DefaultVal;
		}
	}
	
	public static void UpdateConfig(AbsConfig OLD, AbsConfig NW) {
		List<String> F = new ArrayList<String>();
		F.addAll(NW.InternalSave.keySet());
		for (String string : F) {
			NW.edit(string, OLD.get(string));
		}		
		try {
			NW.Save();
		} catch (IOException e) {
			Debug.Trace(e);
		}
		
		
	}
	
	
}
